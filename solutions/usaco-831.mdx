---
id: usaco-831
source: USACO Bronze 2018 Open
title: Team Tic Tac Toe
author: Jesse Choe, Kevin Sheng, Benjamin Qi, Brad Ma, Qian Qian
---

## Solution 1

[Official Analysis (C++)](http://www.usaco.org/current/data/sol_tttt_bronze_open18.html)

<LanguageSection>
	
<JavaSection>
	
```java
import java.util.*;
import java.io.*;

public class TeamTicTacToe {
	static char[][] board = new char[3][3];

	// Does 1 cow win?
	static int cowWins(char ch) {
		// Check diagonals
		if (board[0][0] == ch && board[1][1] == ch && board[2][2] == ch) {
			return 1;
		}
		if (board[0][2] == ch && board[1][1] == ch && board[2][0] == ch) {
			return 1;
		}

		// Check rows and columns
		for (int i = 0; i < 3; i++) {
			if (board[0][i] == ch && board[1][i] == ch && board[2][i] == ch) {
				return 1;
			}
			if (board[i][0] == ch && board[i][1] == ch && board[i][2] == ch) {
				return 1;
			}
		}
		return 0;
	}

	// Test if a team wins based on 3 characters in a row, column, or diagonal
	static boolean check3(char ch1, char ch2, char a, char b, char c) {
		// All 3 characters have to be either ch1 or ch2
		if (a != ch1 && a != ch2) {
			return false;
		}
		if (b != ch1 && b != ch2) {
			return false;
		}
		if (c != ch1 && c != ch2) {
			return false;
		}

		// ch1 and ch2 have to appear at least once each
		if (a != ch1 && b != ch1 && c != ch1) {
			return false;
		}
		if (a != ch2 && b != ch2 && c != ch2) {
			return false;
		}

		return true;
	}

	// Does a team win?
	static int teamWins(char ch1, char ch2) {
		// Check diagonals
		if (check3(ch1, ch2, board[0][0], board[1][1], board[2][2])) {
			return 1;
		}
		if (check3(ch1, ch2, board[0][2], board[1][1], board[2][0])) {
			return 1;
		}

		// Check rows and columns
		for (int i = 0; i < 3; i++) {
			if (check3(ch1, ch2, board[0][i], board[1][i], board[2][i])) {
				return 1;
			}
			if (check3(ch1, ch2, board[i][0], board[i][1], board[i][2])) {
				return 1;
			}
		}

		return 0;
	}

	public static void main(String[] args) throws IOException {
		Kattio io = new Kattio("tttt");

		for (int i = 0; i < 3; i++) {
			String line = io.next();
			for (int j = 0; j < 3; j++) {
				board[i][j] = line.charAt(j);
			}
		}

		int answer1 = 0;
		int answer2 = 0;
		for (char ch = 'A'; ch <= 'Z'; ch++) {
			answer1 += cowWins(ch);
		}

		for (char ch1 = 'A'; ch1 <= 'Z'; ch1++) {
			for (char ch2 = (char) ((int) ch1 + 1); ch2 <= 'Z'; ch2++) {
				answer2 += teamWins(ch1, ch2);
			}
		}

		io.println(answer1 + "\n" + answer2);
		io.close();
	}
	//CodeSnip{Kattio}
}
```
	
</JavaSection>
	
<PySection>

```py
# We are going to loop over all the letters and possible combinations to find the winners

# Read in the file
fin = open('tttt.in', 'r')
fout = open('tttt.out', 'w')

board = []
for i in range(3):
	board.append(fin.readline().strip())

# Check for individual winners:
alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
soloWins = 0
for letter in alphabet:
	# Check diagonals
	if board[0][0] == letter and board[1][1] == letter and board[2][2] == letter:
		soloWins += 1
		continue
	# We need the continue for the following conditionals because we don't want to double count a team win
	if board[0][2] == letter and board[1][1] == letter and board[2][0] == letter:
		soloWins += 1
		continue
	# Check rows and columns
	for i in range(3):
		# Break instead of continue here because there are two for loops
		if board[i][0] == letter and board[i][1] == letter and board[i][2] == letter:
			soloWins += 1
			break
		if board[0][i] == letter and board[1][i] == letter and board[2][i] == letter:
			soloWins += 1
			break

# Function to check if a team won:
def check_team_win(ch1, ch2, a, b, c):
	# When can't a team win? If none of the three characters are ch1 or ch2,
	# the team of ch1 and ch2 can't win
	if a != ch1 and a != ch2:
		return False
	if b != ch1 and b != ch2:
		return False
	if c != ch1 and c != ch2:
		return False

	# They also can't win if each character doesn't appear at least once.
	# Otherwise, we would be counting an individual win twice.
	if a != ch1 and b != ch1 and c != ch1:
		return False
	if a != ch2 and b != ch2 and c != ch2:
		return False

	# If we get here, the team can win!
	return True


# Check for team winners:
teamWins = 0
for l1_index in range(26):
	for l2_index in range(l1_index + 1, 26):
	# Check diagonals
		if check_team_win(alphabet[l1_index],alphabet[l2_index], board[0][0], board[1][1], board[2][2]):
			teamWins += 1
			continue
		if check_team_win(alphabet[l1_index], alphabet[l2_index], board[0][2], board[1][1], board[2][0]):
			teamWins += 1
			continue
		# Check rows and columns
		for i in range(3):
			if check_team_win(alphabet[l1_index], alphabet[l2_index], board[0][i], board[1][i], board[2][i]):
				teamWins += 1
				break
			if check_team_win(alphabet[l1_index], alphabet[l2_index], board[i][0], board[i][1], board[i][2]):
				teamWins += 1
				break

fout.write(str(soloWins) + '\n' + str(teamWins) + '\n')

```

</PySection>
</LanguageSection>

## Solution 2 - Using Sets

<LanguageSection>
<CPPSection>

```cpp
#include <bits/stdc++.h>  // may the c++ gods forgive me

using namespace std;

constexpr int WIDTH = 3;

vector<string> board(WIDTH);
set<set<char>> winners[WIDTH + 1];

void insert(vector<pair<int, int>> coordinates) {
	set<char> contained;
	for (const pair<int, int>& p: coordinates) {
		contained.insert(board[p.first][p.second]);
	}
	// add the amount of cows who contributed to this to the winners count
	winners[contained.size()].insert(contained);
}

// 2018 usopen bronze
int main() {
	ifstream read("tttt.in");
	for (int r = 0; r < WIDTH; r++) {
		read >> board[r];
	}
	// insert rows
	for (int i = 0; i < WIDTH; i++) {
		insert({{i, 0}, {i, 1}, {i, 2}});
	}
	// insert columns
	for (int i = 0; i < WIDTH; i++) {
		insert({{0, i}, {1, i}, {2, i}});
	}
	// insert the 2 diagonals
	insert({{0, 0}, {1, 1}, {2, 2}});
	insert({{2, 0}, {1, 1}, {0, 2}});

	ofstream written("tttt.out");
	written << winners[1].size() << endl;
	written << winners[2].size() << endl;
}
```

</CPPSection>


<PySection>

```py
""
Using a set:
The basic idea is that if you take the set of the diagonals, rows, and columns,
If the length of a set is 1, you have a solo win
If the length of a set is 2, you have a team win
Just don't forget to check for a cow/team winning twice
"""

# Read in the input
fin = open('tttt.in', 'r')
fout = open('tttt.out', 'w')

board = []
for i in range(3):
	board.append(fin.readline().strip())

# Append the rows, columns, and diagonals to a set
board_set_list = []
# Rows
for i in range(3):
	board_set_list.append(set(board[i]))
# Columns
for i in range(3):
	board_set_list.append(set(board[0][i] + board[1][i] + board[2][i]))
# Diagonals
board_set_list.append(set(board[0][0] + board[1][1] + board[2][2]))
board_set_list.append(set(board[0][2] + board[1][1] + board[2][0]))

print(board_set_list)
winners = set()
soloWins = 0
teamWins = 0
for thing in board_set_list:
	e = None
	thing = list(thing)
	if len(thing) == 1:
		if thing[0] not in winners: # We don't want to double count a solo win
			soloWins += 1
			winners.add(thing[0])

	elif len(thing) == 2:
		if (thing[0], thing[1]) not in winners: # Don't want to double count team wins either
			teamWins += 1
			winners.add((thing[0], thing[1]))

fout.write(str(soloWins) + '\n' + str(teamWins) + '\n')
```

</PySection>

<JavaSection>

```java
import java.io.*;
import java.util.*;

public class TeamTicTacToe {
	private static char[][] gameboard = new char[3][3];
	private static Set<Character> singleCow = new TreeSet<>();
	private static Set<String> teams = new TreeSet<>();
	
	private static void check(char first, char second, char third) {
		// Stores unique cows in a row/column/diagonal
		TreeSet<Character> contained = new TreeSet<>();
		contained.add(first);
		contained.add(second);
		contained.add(third);
		if (contained.size() == 1) {
			// There is only one unique cow
			singleCow.add(contained.first());
		} else if (contained.size() == 2) {
			// There are two unique cows
			teams.add(contained.first() + "" + contained.last());
		}
	}
	
	public static void main(String[] args) throws IOException {
		Kattio io = new Kattio("tttt");
		
		for (int i = 0; i < gameboard.length; i++) {
			String line = io.next();
			gameboard[i][0] = line.charAt(0);
			gameboard[i][1] = line.charAt(1);
			gameboard[i][2] = line.charAt(2);
		}
		
		// Check rows
		for (int i = 0; i < gameboard.length; i++) {
			check(gameboard[i][0], gameboard[i][1], gameboard[i][2]);
		}
		
		// Check columns
		for (int i = 0; i < gameboard.length; i++) {
			check(gameboard[0][i], gameboard[1][i], gameboard[2][i]);
		}
		
		// Check diagonals
		check(gameboard[0][0], gameboard[1][1], gameboard[2][2]);
		check(gameboard[0][2], gameboard[1][1], gameboard[2][0]);
		
		io.println(singleCow.size());
		io.println(teams.size());
		
		io.close();
	}
	
	//CodeSnip{Kattio}
	
}

```

</JavaSection>


</LanguageSection>
